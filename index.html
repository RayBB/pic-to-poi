<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSM Tag Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.js"></script>
    <script src='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js'></script>
    <link href='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css' rel='stylesheet' />
    <style>
        .magnifier {
            position: absolute;
            pointer-events: none;
            border: 2px solid white;
            border-radius: 50%;
            cursor: none;
            width: 150px;
            height: 150px;
            display: none;
        }

        #poi-sidebar {
            position: fixed;
            right: 0;
            top: 0;
            bottom: 0;
            width: 300px;
            background: white;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }

        #poi-sidebar.active {
            transform: translateX(0);
        }

        .center-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: red;
            border: 2px solid white;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
        "@google/generative-ai": "https://esm.run/@google/generative-ai"
        }
    }
    </script>
</head>

<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <div class="bg-white p-8 rounded-lg shadow-md w-full max-w-6xl">
        <h1 class="text-3xl font-bold mb-4 text-center">OSM Tag Generator</h1>
        <div id="drop-area"
            class="border-4 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition-colors mb-8">
            <p class="text-gray-600">Drag and drop your images here, or click to select files (max 20)</p>
            <!-- Note, we must accept */* otherwise GPS data is stripped from the exif on mobile -->
            <input type="file" id="fileInput" class="hidden" multiple  accept="*/*">
        </div>
        <div id="image-list" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8 hidden"></div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <div>
                <div id="map-container" class="mb-8">
                    <h2 class="text-2xl font-semibold mb-4">Image Location:</h2>
                    <div id="map" class="h-64 rounded-lg relative">
                        <button id="locate-me" class="absolute top-2 right-2 bg-white p-2 rounded-md shadow-md z-10">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                        </button>
                        <button id="add-center-icon"
                            class="absolute top-2 right-12 bg-white p-2 rounded-md shadow-md z-10">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 4v16m8-8H4" />
                            </svg>
                        </button>
                    </div>
                    <div id="center-coordinates" class="mt-2 text-sm text-gray-600"></div>
                </div>
                <div id="image-container" class="hidden relative">
                    <h2 class="text-2xl font-semibold mb-4">Selected Image:</h2>
                    <div class="relative inline-block">
                        <img id="selected-image" class="max-w-full h-auto rounded-lg" alt="Selected image">
                        <div class="magnifier"></div>
                    </div>
                </div>
            </div>
            <div>
                <div id="tags-container" class="mb-8">
                    <h2 class="text-2xl font-semibold mb-4">Image Tags:</h2>
                    <div class="flex gap-2 mb-4">
                        <button id="calculate-tags"
                            class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                            Calculate Tags
                        </button>
                        <button id="copy-tags"
                            class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">
                            Copy Tags
                        </button>
                    </div>
                    <textarea id="tags-textarea"
                        class="w-full h-40 p-2 border rounded resize-none font-mono mb-4"></textarea>
                    <div id="reasoning" class="text-sm text-gray-600"></div>
                </div>
                <div id="exif-data" class="collapsible-section hidden">
                    <h2 class="text-2xl font-semibold mb-4 cursor-pointer flex items-center"
                        onclick="toggleSection('exif-data')">
                        EXIF Data
                        <svg xmlns="http://www.w3.org/2000/svg"
                            class="h-6 w-6 ml-2 transform transition-transform duration-200" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                        </svg>
                    </h2>
                    <div id="exif-table" class="collapsible-content grid grid-cols-2 gap-2 hidden"></div>
                </div>
            </div>
        </div>
    </div>
    <div id="poi-sidebar" class="p-4">
        <h3 class="text-xl font-bold mb-2">POI Tags</h3>
        <div id="poi-tags"></div>
    </div>

    <script type="module">
        import { GoogleGenerativeAI } from "@google/generative-ai";
        import { generateTagsPrompt } from './prompt.js';

        // Function to get API key from URL or local storage
        function getAPIKey() {
            const urlParams = new URLSearchParams(window.location.search);
            const apiKeyFromURL = urlParams.get('gemini_api_key');
            
            if (apiKeyFromURL) {
                localStorage.setItem('gemini_api_key', apiKeyFromURL);
                // Remove the API key from the URL
                window.history.replaceState({}, document.title, window.location.pathname);
                return apiKeyFromURL;
            }
            
            return localStorage.getItem('gemini_api_key');
        }

        // Get the API key
        const GEMINI_API_KEY = getAPIKey();

        // Check if API key is available
        if (!GEMINI_API_KEY) {
            console.error("No Gemini API key found. Please provide an API key in the URL using ?gemini_api_key=YOUR_API_KEY");
            showToast("No Gemini API key found. Please provide an API key in the URL.", "error");
        }

        const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);

        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('fileInput');
        const exifData = document.getElementById('exif-data');
        const exifTable = document.getElementById('exif-table');

        dropArea.addEventListener('click', () => fileInput.click());
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.classList.add('border-blue-500');
        });
        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('border-blue-500');
        });
        dropArea.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileSelect);

        let magnificationLevel = 1;
        const magnificationFactors = [2, 5, 10]; // Increased factors for more intense magnification

        let uploadedImageData; // To store the uploaded image data

        const imageList = document.getElementById('image-list');
        let uploadedImages = [];

        function handleDrop(e) {
            e.preventDefault();
            dropArea.classList.remove('border-blue-500');
            const files = e.dataTransfer.files;
            processFiles(files);
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            processFiles(files);
        }

        function processFiles(files) {
            const newFiles = Array.from(files).slice(0, 20 - uploadedImages.length);
            newFiles.forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const imageData = {
                            src: e.target.result,
                            file: file,
                            id: Date.now() + Math.random() // Add a unique identifier
                        };
                        uploadedImages.push(imageData);
                        refreshImageList();
                    }
                    reader.readAsDataURL(file);
                }
            });
        }

        function refreshImageList() {
            imageList.innerHTML = '';
            if (uploadedImages.length > 1) {
                imageList.classList.remove('hidden');
                uploadedImages.forEach((imageData, index) => {
                    displayImageThumbnail(imageData, index);
                });
            } else {
                imageList.classList.add('hidden');
            }

            // If there's at least one image, select the first one
            if (uploadedImages.length > 0) {
                selectImage(0);
            }
        }

        function displayImageThumbnail(imageData, index) {
            const thumbnail = document.createElement('div');
            thumbnail.className = 'relative';
            thumbnail.innerHTML = `
                <img src="${imageData.src}" alt="Thumbnail" class="w-full h-32 object-cover rounded-lg cursor-pointer">
                <button class="absolute top-0 right-0 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center" data-id="${imageData.id}">×</button>
            `;
            thumbnail.querySelector('img').addEventListener('click', () => selectImage(index));
            thumbnail.querySelector('button').addEventListener('click', (e) => removeImage(e.target.dataset.id));
            imageList.appendChild(thumbnail);
        }

        function selectImage(index) {
            const imageData = uploadedImages[index];
            const selectedImage = document.getElementById('selected-image');
            selectedImage.src = imageData.src;
            document.getElementById('image-container').classList.remove('hidden');
            setupMagnifier();
            EXIF.getData(imageData.file, function () {
                displayExifData(this);
                displayMap(EXIF.getAllTags(this)); // Call displayMap with EXIF data
            });
        }

        function removeImage(id) {
            const index = uploadedImages.findIndex(img => img.id.toString() === id);
            if (index !== -1) {
                uploadedImages.splice(index, 1);
                refreshImageList();
            }
        }

        function setupMagnifier() {
            const img = document.getElementById('selected-image');
            const magnifier = document.querySelector('.magnifier');

            img.addEventListener('mousemove', updateMagnifier);
            img.addEventListener('mouseleave', () => {
                magnifier.style.display = 'none';
            });
            img.addEventListener('click', cycleMagnification);
        }

        function updateMagnifier(e) {
            const img = document.getElementById('selected-image');
            const magnifier = document.querySelector('.magnifier');
            const rect = img.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const factor = magnificationFactors[magnificationLevel - 1];

            magnifier.style.display = 'block';
            magnifier.style.left = `${x - 75}px`;
            magnifier.style.top = `${y - 75}px`;
            magnifier.style.backgroundImage = `url(${img.src})`;
            magnifier.style.backgroundPosition = `-${x * factor - 75}px -${y * factor - 75}px`;
            magnifier.style.backgroundSize = `${img.width * factor}px ${img.height * factor}px`;
        }

        function cycleMagnification() {
            magnificationLevel = (magnificationLevel % 3) + 1;
            updateMagnifier(event);
        }

        function displayExifData(img) {
            const exifContainer = document.getElementById('exif-data');
            const exifTable = document.getElementById('exif-table');
            exifTable.innerHTML = '';
            const allMetaData = EXIF.getAllTags(img);

            for (const [key, value] of Object.entries(allMetaData)) {
                const row = createTableRow(key, value);
                exifTable.appendChild(row);
            }

            exifContainer.classList.remove('hidden');
        }

        function createTableRow(key, value) {
            const row = document.createElement('div');
            row.className = 'col-span-2 grid grid-cols-2 border-b border-gray-200 py-2';

            const keyElement = document.createElement('div');
            keyElement.className = 'font-semibold';
            keyElement.textContent = key;

            const valueElement = document.createElement('div');
            valueElement.textContent = value;

            row.appendChild(keyElement);
            row.appendChild(valueElement);
            return row;
        }

        // Generic function to toggle any collapsible section
        window.toggleSection = function (sectionId) {
            const section = document.getElementById(sectionId);
            const content = section.querySelector('.collapsible-content');
            const arrow = section.querySelector('svg');

            content.classList.toggle('hidden');
            arrow.classList.toggle('rotate-180');
        }

        let map; // Declare map variable at a higher scope
        let userLocationMarker;
        let centerIcon;
        let centerCoordinatesDisplay;

        const MADISON_SQ_GARDEN = [-73.9934, 40.7505]; // Longitude, Latitude

        // Add these functions to handle localStorage
        function saveLastLocation(location) {
            localStorage.setItem('lastLocation', JSON.stringify(location));
        }

        function getLastLocation() {
            const lastLocation = localStorage.getItem('lastLocation');
            return lastLocation ? JSON.parse(lastLocation) : null;
        }

        // Add this function to get the user's location
        function getUserLocation() {
            return new Promise((resolve, reject) => {
                if ("geolocation" in navigator) {
                    navigator.geolocation.getCurrentPosition(
                        position => resolve([position.coords.longitude, position.coords.latitude]),
                        error => reject(error)
                    );
                } else {
                    reject(new Error("Geolocation is not supported by this browser."));
                }
            });
        }

        // Modify the displayMap function
        async function displayMap(exifData) {
            const mapContainer = document.getElementById('map-container');
            mapContainer.classList.remove('hidden');

            let center = getLastLocation() || MADISON_SQ_GARDEN;
            if (exifData && exifData.GPSLatitude && exifData.GPSLongitude) {
                const lat = convertDMSToDD(exifData.GPSLatitude, exifData.GPSLatitudeRef);
                const lon = convertDMSToDD(exifData.GPSLongitude, exifData.GPSLongitudeRef);
                center = [lon, lat];
            }

            if (!map) {
                map = new maplibregl.Map({
                    container: 'map',
                    style: '/osm_liberty.json',
                    center: center,
                    zoom: 18
                });

                // Add locate me button functionality
                document.getElementById('locate-me').addEventListener('click', moveToUserLocation);

                // Add center icon button functionality
                document.getElementById('add-center-icon').addEventListener('click', addCenterIcon);

                // Save location when the map moves
                map.on('moveend', () => {
                    const center = map.getCenter();
                    saveLastLocation([center.lng, center.lat]);
                    updateCenterCoordinates();
                });

                centerCoordinatesDisplay = document.getElementById('center-coordinates');
            } else {
                map.setCenter(center);
            }

            // Clear existing markers
            const markers = document.getElementsByClassName('maplibregl-marker');
            while (markers[0]) {
                markers[0].parentNode.removeChild(markers[0]);
            }

            // Add marker for the current location
            new maplibregl.Marker()
                .setLngLat(center)
                .addTo(map);

            // Fetch and display POIs
            const pois = await fetchPOIs(center[1], center[0]);
            displayPOIs(pois);

            // Save the current location
            saveLastLocation(center);

            // Trigger a resize event after the map is displayed
            setTimeout(() => {
                map.resize();
            }, 0);
        }

        async function moveToUserLocation() {
            try {
                const userLocation = await getUserLocation();
                map.flyTo({ center: userLocation, zoom: 18 });

                // Remove existing user location marker if it exists
                if (userLocationMarker) {
                    userLocationMarker.remove();
                }

                // Add new user location marker
                userLocationMarker = new maplibregl.Marker({ color: '#3FB1CE' })
                    .setLngLat(userLocation)
                    .addTo(map);

                // Fetch and display POIs for the new location
                const pois = await fetchPOIs(userLocation[1], userLocation[0]);
                displayPOIs(pois);

                // Save the user location
                saveLastLocation(userLocation);
            } catch (error) {
                console.error("Error getting user location:", error);
                showToast("Unable to get your location. Please check your browser settings.", "error");
            }
        }

        function addCenterIcon() {
            if (centerIcon) {
                // If the center icon exists, remove it and reset
                centerIcon.remove();
                centerIcon = null;
                centerCoordinatesDisplay.textContent = '';
                map.off('move', updateCenterIconPosition);
            } else {
                // If the center icon doesn't exist, create and add it
                const centerIconElement = document.createElement('div');
                centerIconElement.className = 'center-icon';

                centerIcon = new maplibregl.Marker({
                    element: centerIconElement,
                    anchor: 'center'
                })
                    .setLngLat(map.getCenter())
                    .addTo(map);

                // Update the icon's position when the map moves
                map.on('move', updateCenterIconPosition);

                updateCenterCoordinates();
            }
        }

        function updateCenterIconPosition() {
            if (centerIcon) {
                centerIcon.setLngLat(map.getCenter());
                updateCenterCoordinates();
            }
        }

        function updateCenterCoordinates() {
            if (centerIcon) {
                const center = map.getCenter();
                const lat = center.lat.toFixed(6);
                const lng = center.lng.toFixed(6);
                centerCoordinatesDisplay.textContent = `Center: ${lat}, ${lng}`;
            }
        }

        // Add this function to display POIs
        function displayPOIs(pois) {
            pois.forEach(poi => {
                const el = document.createElement('div');
                el.className = 'marker';
                el.style.backgroundColor = 'red';
                el.style.width = '10px';
                el.style.height = '10px';
                el.style.borderRadius = '50%';

                new maplibregl.Marker(el)
                    .setLngLat([poi.lon, poi.lat])
                    .addTo(map)
                    .getElement().addEventListener('click', () => showPOITags(poi));
            });
        }

        async function fetchPOIs(lat, lon) {
            const query = `
                [out:json];
                (
                  node["name"](around:500,${lat},${lon});
                  way["name"](around:500,${lat},${lon});
                  relation["name"](around:500,${lat},${lon});
                );
                out body;
            `;
            const response = await fetch('https://overpass-api.de/api/interpreter', {
                method: 'POST',
                body: query
            });
            const data = await response.json();
            return data.elements;
        }

        function showPOITags(poi) {
            const sidebar = document.getElementById('poi-sidebar');
            const tagsContainer = document.getElementById('poi-tags');
            tagsContainer.innerHTML = '';

            // Create a container for the buttons
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'flex gap-2 mb-4';

            // Add edit link
            const editLink = document.createElement('a');
            editLink.href = `https://www.openstreetmap.org/edit?${poi.type}=${poi.id}`;
            editLink.target = '_blank';
            editLink.className = 'bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded';
            editLink.textContent = 'Edit in iD';
            buttonContainer.appendChild(editLink);

            // Add copy tags button
            const copyButton = document.createElement('button');
            copyButton.className = 'bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded';
            copyButton.textContent = 'Copy Tags';
            copyButton.addEventListener('click', () => copyPOITags(poi.tags));
            buttonContainer.appendChild(copyButton);

            tagsContainer.appendChild(buttonContainer);

            // Display tags
            for (const [key, value] of Object.entries(poi.tags)) {
                const tagElement = document.createElement('div');
                tagElement.className = 'mb-2';
                tagElement.innerHTML = `<strong>${key}:</strong> ${value}`;
                tagsContainer.appendChild(tagElement);
            }

            sidebar.classList.add('active');
        }

        function copyPOITags(tags) {
            const formattedTags = Object.entries(tags)
                .map(([key, value]) => `${key}=${value}`)
                .join('\n');
            navigator.clipboard.writeText(formattedTags)
                .then(() => showToast('POI tags copied to clipboard!'))
                .catch(err => {
                    console.error('Failed to copy tags: ', err);
                    showToast('Failed to copy tags', 'error');
                });
        }

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `fixed bottom-4 right-4 px-4 py-2 rounded-lg text-white 
            ${type === 'success' ? 'bg-green-500' : 'bg-red-500'} transition-opacity duration-300 opacity-0 z-50`;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Fade in
            setTimeout(() => {
                toast.style.opacity = '1';
            }, 10);

            // Fade out and remove
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }

        // Add event listener to close sidebar when clicking outside
        document.addEventListener('click', (e) => {
            const sidebar = document.getElementById('poi-sidebar');
            if (!sidebar.contains(e.target) && !e.target.closest('.marker')) {
                sidebar.classList.remove('active');
            }
        });

        function convertDMSToDD(dms, ref) {
            const degrees = dms[0];
            const minutes = dms[1];
            const seconds = dms[2];

            let dd = degrees + minutes / 60 + seconds / 3600;

            if (ref === "S" || ref === "W") {
                dd = -dd;
            }

            return dd;
        }

        const calculateTagsButton = document.getElementById('calculate-tags');
        const tagsTextarea = document.getElementById('tags-textarea');
        const copyTagsButton = document.getElementById('copy-tags');

        calculateTagsButton.addEventListener('click', calculateTags);
        copyTagsButton.addEventListener('click', copyTags);

        async function calculateTags() {
            if (!GEMINI_API_KEY) {
                showToast("API key is missing. Please provide an API key in the URL.", "error");
                return;
            }

            const calculateTagsButton = document.getElementById('calculate-tags');

            // Reset button state if it's already in "calculated" state
            if (calculateTagsButton.textContent.startsWith('Calculated in')) {
                calculateTagsButton.textContent = 'Calculate Tags';
                calculateTagsButton.classList.remove('bg-green-500', 'hover:bg-green-700');
                calculateTagsButton.classList.add('bg-blue-500', 'hover:bg-blue-700');
            }

            const selectedImage = document.getElementById('selected-image');
            if (!selectedImage.src) {
                showToast("Please select an image first.", "error");
                return;
            }

            const originalButtonText = calculateTagsButton.textContent;
            const startTime = Date.now();
            let timerInterval;

            // Function to update the button text
            const updateButtonText = () => {
                const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
                calculateTagsButton.textContent = `Calculating... ${elapsedSeconds}s`;
            };

            // Start updating the button text
            timerInterval = setInterval(updateButtonText, 100);
            calculateTagsButton.disabled = true;

            // NOTE Gemini 1.5 Flash DOES support images!
            const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

            const imageParts = [];
            
            // Iterate through all uploaded images
            for (const imageData of uploadedImages) {
                const [mimeType, base64Data] = imageData.src.split(',');
                const extractedMimeType = mimeType.split(':')[1].split(';')[0];

                // Check if the MIME type is supported
                const supportedMimeTypes = [
                    "image/png",
                    "image/jpeg",
                    "image/webp",
                    "image/heic",
                    "image/heif"
                ];

                if (supportedMimeTypes.includes(extractedMimeType)) {
                    imageParts.push({
                        inlineData: {
                            data: base64Data,
                            mimeType: extractedMimeType
                        }
                    });
                } else {
                    console.warn(`Skipping unsupported image format: ${extractedMimeType}`);
                }
            }

            if (imageParts.length === 0) {
                clearInterval(timerInterval);
                calculateTagsButton.textContent = originalButtonText;
                calculateTagsButton.disabled = false;
                showToast("No supported images found. Please upload PNG, JPEG, WEBP, HEIC, or HEIF images.", "error");
                return;
            }
            console.log(imageParts);


            const generationConfig = {
                temperature: 1,
                topP: 0.95,
                topK: 64,
                maxOutputTokens: 1000,
                responseMimeType: "application/json",
                responseSchema: {
                    type: "object",
                    properties: {
                        reasoning: {
                            type: "string"
                        },
                        tags: {
                            type: "array",
                            items: {
                                type: "string"
                            }
                        }
                    },
                    required: ["reasoning", "tags"]
                }
            };

            try {
                const result = await model.generateContent({
                    contents: [{ role: "user", parts: [{ text: generateTagsPrompt }, ...imageParts] }],
                    generationConfig: generationConfig,
                });

                const response = result.response;
                const jsonResponse = JSON.parse(response.text());

                displayTags(jsonResponse.tags);
                displayReasoning(jsonResponse.reasoning);
            } catch (error) {
                console.error("Error generating tags:", error);
                showToast("Error generating tags. Please check the console for details.", "error");
            } finally {
                clearInterval(timerInterval);
                const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
                calculateTagsButton.textContent = `Calculated in ${totalTime}s`;
                calculateTagsButton.classList.add('bg-green-500', 'hover:bg-green-700');
                calculateTagsButton.classList.remove('bg-blue-500', 'hover:bg-blue-700');

                // Remove the setTimeout and keep the button in its "calculated" state
                calculateTagsButton.disabled = false;
            }
        }

        function displayTags(tags) {
            tagsTextarea.value = tags.join('\n');
        }

        function displayReasoning(reasoning) {
            const reasoningElement = document.getElementById('reasoning');
            reasoningElement.textContent = reasoning;
        }

        function copyTags() {
            navigator.clipboard.writeText(tagsTextarea.value)
                .then(() => showToast('Tags copied to clipboard!'))
                .catch(err => {
                    console.error('Failed to copy tags: ', err);
                    showToast('Failed to copy tags', 'error');
                });
        }

        // Call displayMap on page load to show the initial map
        window.addEventListener('load', () => {
            displayMap();
        });
    </script>
</body>

</html>